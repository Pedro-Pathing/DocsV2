---
title: Choosing a Dashboard
description: Panels or the FTC Dashboard
---

It is best to use Pedro Pathing with a dashboard to assist in tuning and viewing paths live. You may use either [Panels](https://panels.bylazar.com) or the [FTC Dashboard](https://acmerobotics.github.io/ftc-dashboard). The quickstart comes with Panels installed by default. If you are not using the quickstart or would like to use FTC Dashboard instead, follow the installation instructions on the dashboard of your choice.

## Panels

Panels is an intuitive, real-time dashboard for FTC. It supports live tuning of constants, visualizing the robot on the field, and logging & graphing the robot's state live. It is fully supported by Pedro Pathing and accessible at the ip address `192.168.43.1:8001` when connected to robot wifi.

## FTC Dashboard

The FTC Dashboard is a web app for monitoring FTC robots during operation. Like Panels, it supports visualizing the robot on the field and logging & graphing the robot's state live. However, because of the complexity of Pedro Pathing's constants, it does not support live tuning of Pedro Pathing.

## Drawing Class

For either option, it is likely that you will want to use the field view optionality. Built in to the Quickstart is the Drawing class for Panels, located in the `Tuning.java` file. This class is in charge of drawing the robot and its paths on to the field view to show live position and desired position and path. You should be able to copy and paste either of these two for your selected dashboard of choice.

### FTC Dash

You will have to remove the @Configurable annotations from the Tuning class in favor for the @Config annotation. Also remove any @IgnoreConfigurable annotations. All of the Tuning classes use Panels `telemetryM.debug()` and `telemetryM.update()` methods, those will have to be replaced by `telemetryA.addLine()` and `telemetryA.update()`.

At the top of the file, add these imports:

```java
import com.acmerobotics.dashboard.FtcDashboard;
import com.acmerobotics.dashboard.canvas.Canvas;
import com.acmerobotics.dashboard.telemetry.TelemetryPacket;
import com.acmerobotics.dashboard.config.Config;
import com.acmerobotics.dashboard.telemetry.MultipleTelemetry;
```

Replace or add this code as the Drawing class:

```java
class Drawing {
    public static final double ROBOT_RADIUS = 9;
    private static TelemetryPacket packet;

    public static void drawDebug(Follower follower) {
        if (follower.getCurrentPath() != null) {
            drawPath(follower.getCurrentPath(), "#3F51B5");
            Pose closestPoint = follower.getPointFromPath(follower.getCurrentPath().getClosestPointTValue());
            drawRobot(new Pose(closestPoint.getX(), closestPoint.getY(), follower.getCurrentPath().getHeadingGoal(follower.getCurrentPath().getClosestPointTValue())), "#3F51B5");
        }
        drawPoseHistory(follower.getPoseHistory(), "#4CAF50");
        drawRobot(follower.getPose(), "#4CAF50");
        sendPacket();
    }

    public static void drawRobot(Pose pose, String color) {
        if (packet == null) packet = new TelemetryPacket();
        packet.fieldOverlay().setStroke(color);
        Drawing.drawRobotOnCanvas(packet.fieldOverlay(), pose.copy());
    }

    public static void drawPath(Path path, String color) {
        if (packet == null) packet = new TelemetryPacket();
        packet.fieldOverlay().setStroke(color);
        Drawing.drawPath(packet.fieldOverlay(), path.getPanelsDrawingPoints());
    }

    public static void drawPath(PathChain pathChain, String color) {
        for (int i = 0; i < pathChain.size(); i++) {
            drawPath(pathChain.getPath(i), color);
        }
    }

    public static void drawPoseHistory(PoseHistory poseTracker, String color) {
        if (packet == null) packet = new TelemetryPacket();
        packet.fieldOverlay().setStroke(color);
        packet.fieldOverlay().strokePolyline(poseTracker.getXPositionsArray(), poseTracker.getYPositionsArray());
    }

    public static boolean sendPacket() {
        if (packet != null) {
            FtcDashboard.getInstance().sendTelemetryPacket(packet);
            packet = null;
            return true;
        }
        return false;
    }

    public static void drawRobotOnCanvas(Canvas c, Pose t) {
        if (t == null || Double.isNaN(t.getX()) || Double.isNaN(t.getY()) || Double.isNaN(t.getHeading())) {
            return;
        }
        c.strokeCircle(t.getX(), t.getY(), ROBOT_RADIUS);
        Vector v = t.getHeadingAsUnitVector();
        v.setMagnitude(v.getMagnitude() * ROBOT_RADIUS);
        double x1 = t.getX() + v.getXComponent() / 2, y1 = t.getY() + v.getYComponent() / 2;
        double x2 = t.getX() + v.getXComponent(), y2 = t.getY() + v.getYComponent();
        c.strokeLine(x1, y1, x2, y2);
    }

    public static void drawPath(Canvas c, double[][] points) {
        c.strokePolyline(points[0], points[1]);
    }
}
```

### Panels

The Quickstart comes preinstalled with Panels and already holds the Panels Drawing class. If you want to revert back to Panels from dashboard, follow the steps for Dashboard in reverse or redownload the `Tuning.java` from the Quickstart.

Add these imports at the top of the `Tuning.java` file:

```java
import com.bylazar.configurables.annotations.Configurable;
import com.bylazar.configurables.annotations.IgnoreConfigurable;
import com.bylazar.configurables.PanelsConfigurables;
import com.bylazar.field.FieldManager;
import com.bylazar.field.PanelsField;
import com.bylazar.field.Style;
import com.bylazar.telemetry.PanelsTelemetry;
import com.bylazar.telemetry.TelemetryManager;
```

Replace or add this code as the Drawing class:

```java
class Drawing {
    public static final double ROBOT_RADIUS = 9;
    private static final FieldManager panelsField = PanelsField.INSTANCE.getField();

    private static final Style robotLook = new Style("", "#3F51B5", 0.0);
    private static final Style historyLook = new Style("", "#4CAF50", 0.0);

    public static void init() {
        panelsField.setOffsets(PanelsField.INSTANCE.getPresets().getPEDRO_PATHING());
    }

    public static void drawDebug(Follower follower) {
        if (follower.getCurrentPath() != null) {
            drawPath(follower.getCurrentPath(), robotLook);
            Pose closestPoint = follower.getPointFromPath(follower.getCurrentPath().getClosestPointTValue());
            drawRobot(new Pose(closestPoint.getX(), closestPoint.getY(), follower.getCurrentPath().getHeadingGoal(follower.getCurrentPath().getClosestPointTValue())), robotLook);
        }
        drawPoseHistory(follower.getPoseHistory(), historyLook);
        drawRobot(follower.getPose(), historyLook);
        sendPacket();
    }

    public static void drawRobot(Pose pose, Style style) {
        if (pose == null || Double.isNaN(pose.getX()) || Double.isNaN(pose.getY()) || Double.isNaN(pose.getHeading())) {
            return;
        }
        panelsField.setStyle(style);
        panelsField.moveCursor(pose.getX(), pose.getY());
        panelsField.circle(ROBOT_RADIUS);
        Vector v = pose.getHeadingAsUnitVector();
        v.setMagnitude(v.getMagnitude() * ROBOT_RADIUS);
        double x1 = pose.getX() + v.getXComponent() / 2, y1 = pose.getY() + v.getYComponent() / 2;
        double x2 = pose.getX() + v.getXComponent(), y2 = pose.getY() + v.getYComponent();
        panelsField.setStyle(style);
        panelsField.moveCursor(x1, y1);
        panelsField.line(x2, y2);
    }

    public static void drawRobot(Pose pose) {
        drawRobot(pose, robotLook);
    }

    public static void drawPath(Path path, Style style) {
        double[][] points = path.getPanelsDrawingPoints();
        for (int i = 0; i < points[0].length; i++) {
            for (int j = 0; j < points.length; j++) {
                if (Double.isNaN(points[j][i])) {
                    points[j][i] = 0;
                }
            }
        }
        panelsField.setStyle(style);
        panelsField.moveCursor(points[0][0], points[0][1]);
        panelsField.line(points[1][0], points[1][1]);
    }

    public static void drawPath(PathChain pathChain, Style style) {
        for (int i = 0; i < pathChain.size(); i++) {
            drawPath(pathChain.getPath(i), style);
        }
    }

    public static void drawPoseHistory(PoseHistory poseTracker, Style style) {
        panelsField.setStyle(style);
        int size = poseTracker.getXPositionsArray().length;
        for (int i = 0; i < size - 1; i++) {
            panelsField.moveCursor(poseTracker.getXPositionsArray()[i], poseTracker.getYPositionsArray()[i]);
            panelsField.line(poseTracker.getXPositionsArray()[i + 1], poseTracker.getYPositionsArray()[i + 1]);
        }
    }

    public static void drawPoseHistory(PoseHistory poseTracker) {
        drawPoseHistory(poseTracker, historyLook);
    }

    public static void sendPacket() {
        panelsField.update();
    }
}
```
